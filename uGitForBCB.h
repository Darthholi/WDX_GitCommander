//---------------------------------------------------------------------------
#ifndef uGitForBCBH
#define uGitForBCBH

#include <windows.h>
//#include <Sysutils.hpp>
#include <sys\types.h>
#include <time.h>
typedef __int64 git_off_t;
typedef __int64 git_time_t;
typedef int int32_t;
typedef  __int64 int64_t;

//From LIB:
#define GIT_EXTERN(type) extern "C" __declspec(dllexport) type


//   /** Size (in bytes) of a raw/binary oid */
#define GIT_OID_RAWSZ 20
//   /** Size (in bytes) of a hex formatted oid */
#define GIT_OID_HEXSZ (GIT_OID_RAWSZ * 2)
#define GIT_OID_MINPREFIXLEN 4
#define GIT_PACK_NAME_MAX (5 + 40 + 1)

      typedef enum {
      GIT_OBJ_ANY = -2,		/**< Object can be any of the following */
      GIT_OBJ_BAD = -1,       /**< Object is invalid. */
      GIT_OBJ__EXT1 = 0,      /**< Reserved for future use. */
      GIT_OBJ_COMMIT = 1,     /**< A commit object. */
      GIT_OBJ_TREE = 2,       /**< A tree (directory listing) object. */
      GIT_OBJ_BLOB = 3,       /**< A file revision object. */
      GIT_OBJ_TAG = 4,        /**< An annotated tag object. */
      GIT_OBJ__EXT2 = 5,      /**< Reserved for future use. */
      GIT_OBJ_OFS_DELTA = 6,  /**< A delta, base is given by an offset. */
      GIT_OBJ_REF_DELTA = 7,  /**< A delta, base is given by object id. */
   } git_otype;
   /** Generic return codes */

   /** Generic return codes */
typedef enum {
	GIT_OK         =  0,		/**< No error */

	GIT_ERROR      = -1,		/**< Generic error */
	GIT_ENOTFOUND  = -3,		/**< Requested object could not be found */
	GIT_EEXISTS    = -4,		/**< Object exists preventing operation */
	GIT_EAMBIGUOUS = -5,		/**< More than one object matches */
	GIT_EBUFS      = -6,		/**< Output buffer too short to hold data */

	/* GIT_EUSER is a special error that is never generated by libgit2
	 * code.  You can return it from a callback (e.g to stop an iteration)
	 * to know that it was generated by the callback and not by libgit2.
	 */
	GIT_EUSER      = -7,

	GIT_EBAREREPO       =  -8,	/**< Operation not allowed on bare repository */
	GIT_EUNBORNBRANCH   =  -9,	/**< HEAD refers to branch with no commits */
	GIT_EUNMERGED       = -10,	/**< Merge in progress prevented operation */
	GIT_ENONFASTFORWARD = -11,	/**< Reference was not fast-forwardable */
	GIT_EINVALIDSPEC    = -12,	/**< Name/ref spec was not in a valid format */
	GIT_EMERGECONFLICT  = -13,	/**< Merge conflicts prevented operation */
	GIT_ELOCKED         = -14,	/**< Lock file prevented operation */
	GIT_EMODIFIED       = -15,	/**< Reference value does not match expected */
	GIT_EAUTH           = -16,      /**< Authentication error */
	GIT_ECERTIFICATE    = -17,      /**< Server certificate is invalid */
	GIT_EAPPLIED        = -18,	/**< Patch/merge has already been applied */
	GIT_EPEEL           = -19,      /**< The requested peel operation is not possible */

	GIT_PASSTHROUGH     = -30,	/**< Internal only */
	GIT_ITEROVER        = -31,	/**< Signals end of iteration with iterator */
} git_error_code;

   /**
    * Sort the repository contents in no particular ordering;
    * this sorting is arbitrary, implementation-specific
    * and subject to change at any time.
    * This is the default sorting for new walkers.
    */
   #define GIT_SORT_NONE         (0)

   /**
    * Sort the repository contents in topological order
    * (parents before children); this sorting mode
    * can be combined with time sorting.
    */
   #define GIT_SORT_TOPOLOGICAL  (1 << 0)

   /**
    * Sort the repository contents by commit time;
    * this sorting mode can be combined with
    * topological sorting.
    */
   #define GIT_SORT_TIME         (1 << 1)

   /**
    * Iterate through the repository contents in reverse
    * order; this sorting mode can be combined with
    * any of the above.
    */
   #define GIT_SORT_REVERSE      (1 << 2)

   /** Basic type of any Git reference. */
   typedef enum {
      GIT_REF_INVALID = 0, /** Invalid reference */
      GIT_REF_OID = 1, /** A reference which points at an object id */
      GIT_REF_SYMBOLIC = 2, /** A reference which points at another reference */
      GIT_REF_PACKED = 4,
      GIT_REF_HAS_PEEL = 8,
      GIT_REF_LISTALL = GIT_REF_OID|GIT_REF_SYMBOLIC|GIT_REF_PACKED,
   } git_rtype;

      typedef enum {
      GIT_STREAM_RDONLY = (1 << 1),
      GIT_STREAM_WRONLY = (1 << 2),
      GIT_STREAM_RW = (GIT_STREAM_RDONLY | GIT_STREAM_WRONLY),
   } git_odb_streammode;

   #define GIT_IDXENTRY_UPDATE            (1 << 0)
   #define GIT_IDXENTRY_REMOVE            (1 << 1)
   #define GIT_IDXENTRY_UPTODATE          (1 << 2)
   #define GIT_IDXENTRY_ADDED             (1 << 3)

   #define GIT_IDXENTRY_HASHED            (1 << 4)
   #define GIT_IDXENTRY_UNHASHED          (1 << 5)
   #define GIT_IDXENTRY_WT_REMOVE         (1 << 6) /* remove in work directory */
   #define GIT_IDXENTRY_CONFLICTED        (1 << 7)

   #define GIT_IDXENTRY_UNPACKED          (1 << 8)
   #define GIT_IDXENTRY_NEW_SKIP_WORKTREE (1 << 9)

   /*
    * Extended on-disk flags:
    */
   #define GIT_IDXENTRY_INTENT_TO_ADD     (1 << 13)
   #define GIT_IDXENTRY_SKIP_WORKTREE     (1 << 14)
   /* GIT_IDXENTRY_EXTENDED2 is for future extension */
   #define GIT_IDXENTRY_EXTENDED2         (1 << 15)

   #define GIT_IDXENTRY_EXTENDED_FLAGS (GIT_IDXENTRY_INTENT_TO_ADD | GIT_IDXENTRY_SKIP_WORKTREE)

/*type
   size_t   = LongWord;
   time_t   = Int64;
   off_t = Int64;
   git_off_t = Int64;  //  typedef __int64 git_off_t;
   git_time_t = Int64; //  typedef __time64_t git_time_t;
   PInt32_t = ^Int32;
   PInt64_t = PInt64;

   git_otype            = Integer; // enum as constants above
   git_rtype            = Integer;
   git_odb_streammode   = Integer;

   git_file = Integer;     */

   typedef struct {
      /** raw binary formatted id */
      unsigned char id[GIT_OID_RAWSZ];
   } git_oid;
/*
   PPgit_odb = ^Pgit_odb;
   PPgit_commit = ^Pgit_commit;
   PPgit_index_entry = ^Pgit_index_entry;
   Pgit_index_entry = ^git_index_entry;
   PPgit_index_tree = ^Pgit_index_tree;
   Pgit_signature = ^git_signature;
   PPgit_tree_entry = ^Pgit_tree_entry;
   Pgit_odb_backend = ^git_odb_backend;
   Pgit_strarray = ^git_strarray;
   Pgit_index_entry_unmerged = ^git_index_entry_unmerged;
   Pgit_config_file  = ^git_config_file;

   // structs not translated because they should be internal details,
   // and not necessary from GitForDelphi        */
typedef struct git_odb git_odb;
typedef struct git_commit git_commit;
typedef struct git_index git_index;
typedef struct git_index_tree git_index_tree;
typedef struct git_object git_object;
typedef struct git_tree git_tree;
typedef struct git_tag git_tag;
typedef struct git_blob git_blob;
typedef struct git_reference git_reference;
typedef struct git_repository git_repository;
typedef struct git_tree_entry git_tree_entry;
typedef struct git_rawobj git_rawobj;
typedef struct git_odb_object git_odb_object;
typedef struct git_odb_stream git_odb_stream;
typedef struct git_revwalk git_revwalk;
typedef struct git_treebuilder git_treebuilder;
typedef struct git_config git_config;
typedef struct git_indexer git_indexer;
typedef struct git_indexer_stats git_indexer_stats;
typedef struct git_reflog git_reflog;
typedef struct git_reflog_entry git_reflog_entry;
typedef struct git_remote git_remote;
typedef struct git_refspec git_refspec;
typedef struct git_hash_ctx git_hash_ctx;

typedef int (*git_vector_cmp)(const void *, const void *);

//int (*callback)(const char *, void *);
//int (*callback)(const char *, unsigned int, void *);

typedef int (*git_treewalk_cb)(const char *root, git_tree_entry *entry, void *payload);

   struct git_remote_head {
      int local:1; /* available locally */
      git_oid oid;
      git_oid loid;
      char *name;
   };
//typedef int (*git_headlist_cb)(git_remote_head *, void *);
typedef int (*git_headlist_cb)(void *, void *);

   struct git_odb_backend {
      git_odb *odb;

      int (* read)(
            void **, size_t *, git_otype *,
            struct git_odb_backend *,
            const git_oid *);

      /* To find a unique object given a prefix
       * of its oid.
       * The oid given must be so that the
       * remaining (GIT_OID_HEXSZ - len)*4 bits
       * are 0s.
       */
      int (* read_prefix)(
            git_oid *,
            void **, size_t *, git_otype *,
            struct git_odb_backend *,
            const git_oid *,
            unsigned int);

      int (* read_header)(
            size_t *, git_otype *,
            struct git_odb_backend *,
            const git_oid *);

      int (* write)(
            git_oid *,
            struct git_odb_backend *,
            const void *,
            size_t,
            git_otype);

      int (* writestream)(
            struct git_odb_stream **,
            struct git_odb_backend *,
            size_t,
            git_otype);

      int (* readstream)(
            struct git_odb_stream **,
            struct git_odb_backend *,
            const git_oid *);

      int (* exists)(
            struct git_odb_backend *,
            const git_oid *);

      void (* free)(struct git_odb_backend *);
   };

   typedef struct {
      git_time_t seconds;
      /* nsec should not be stored as time_t compatible */
      unsigned int nanoseconds;
   } git_index_time;

   typedef struct git_index_entry {
      git_index_time ctime;
      git_index_time mtime;

      unsigned int dev;
      unsigned int ino;
      unsigned int mode;
      unsigned int uid;
      unsigned int gid;
      git_off_t file_size;

      git_oid oid;

      unsigned short flags;
      unsigned short flags_extended;

      const char *path;
   } git_index_entry;
   typedef struct git_index_entry_unmerged {
      unsigned int mode[3];
      git_oid oid[3];
      char *path;
   } git_index_entry_unmerged;

   typedef struct {
      volatile int val;
   } git_atomic;

   typedef struct {
      git_oid oid;
      git_atomic refcount;
   } git_cached_obj;

   /** Time in a signature */
   typedef struct git_time {
      time_t time; /** time in seconds from epoch */
      int offset; /** timezone offset, in minutes */
   } git_time;

   /** An action signature (e.g. for committers, taggers, etc) */
   typedef struct git_signature {
      char *name; /** full name of the author */
      char *email; /** email of the author */
      git_time when; /** time when the action happened */
   } git_signature;
   typedef struct {
      char **strings;
      size_t count;
   } git_strarray;

   /*Pgit_treebuilder_filter_filter = ^git_treebuilder_filter_filter;
   git_treebuilder_filter_filter = function (const entry: Pgit_tree_entry; payload: PByte): Integer; stdcall;

   Pgit_config_file_foreach_callback = ^git_config_file_foreach_callback;
   git_config_file_foreach_callback = function (const key, value: PAnsiChar; data: PByte): Integer; stdcall;

   Pgit_config_file_open = ^git_config_file_open;
   Pgit_config_file_get = ^git_config_file_get;
   Pgit_config_file_set = ^git_config_file_set;
   Pgit_config_file_del = ^git_config_file_del;
   Pgit_config_file_foreach = ^git_config_file_foreach;
   Pgit_config_file_free = ^git_config_file_free;

   git_config_file_open    = function (f: Pgit_config_file): Integer; stdcall;
   git_config_file_get     = function (f: Pgit_config_file; const key: PAnsiChar; out value: PAnsiChar): Integer; stdcall;
   git_config_file_set     = function (f: Pgit_config_file; const key, value: PAnsiChar): Integer; stdcall;
   git_config_file_del     = function (f: Pgit_config_file; const key: PAnsiChar): Integer; stdcall;
   git_config_file_foreach = function (f: Pgit_config_file; fn: Pgit_config_file_foreach_callback; data: PByte): Integer; stdcall;
   git_config_file_free    = function (f: Pgit_config_file): Integer; stdcall;   */

   struct git_config_file {
      struct git_config *cfg;

      /* Open means open the file/database and parse if necessary */
      int (*open)(struct git_config_file *);
      int (*get)(struct git_config_file *, const char *key, const char **value);
      int (*set)(struct git_config_file *, const char *key, const char *value);
      int (*del)(struct git_config_file *, const char *key);
      int (*foreach)(struct git_config_file *, int (*fn)(const char *, void *), void *data);
      void (*free)(struct git_config_file *);
   };


//   int (*callback)(const char *var_name, const char *value, void *payload)
//   int (*callback)(const char *name, const char *value, void *payload)

   typedef enum {
      GIT_REPO_PATH,
      GIT_REPO_PATH_INDEX,
      GIT_REPO_PATH_ODB,
      GIT_REPO_PATH_WORKDIR
   } git_repository_pathid;

   /**
 * Init the global state
 *
 * This function must the called before any other libgit2 function in
 * order to set up global state and threading.
 *
 * This function may be called multiple times - it will return the number
 * of times the initialization has been called (including this one) that have
 * not subsequently been shutdown.
 *
 * @return the number of initializations of the library, or an error code.
 */
GIT_EXTERN(int) git_libgit2_init(void);

/**
 * Shutdown the global state
 *
 * Clean up the global state and threading context after calling it as
 * many times as `git_libgit2_init()` was called - it will return the
 * number of remainining initializations that have not been shutdown
 * (after this one).
 * 
 * @return the number of remaining initializations of the library, or an
 * error code.
 */
GIT_EXTERN(int) git_libgit2_shutdown(void);

   /// attr.h
   ///   Attribute management

   GIT_EXTERN(const char *)git_attr__true;
   GIT_EXTERN(const char *)git_attr__false;

   GIT_EXTERN(int) git_attr_get(git_repository *repo, const char *path, const char *name, const char **value);
   GIT_EXTERN(int) git_attr_get_many(git_repository *repo, const char *path, size_t num_attr, const char **names, const char **values);
   GIT_EXTERN(int) git_attr_foreach(git_repository *repo, const char *path, int (*callback)(const char *name, const char *value, void *payload), void *payload);
   GIT_EXTERN(void) git_attr_cache_flush(git_repository *repo);
   GIT_EXTERN(int) git_attr_add_macro(git_repository *repo, const char *name, const char *values);

   /// blob.h
   ///

   GIT_EXTERN(const void *) git_blob_rawcontent(git_blob *blob);
   GIT_EXTERN(size_t) git_blob_rawsize(git_blob *blob);
   GIT_EXTERN(int) git_blob_create_fromfile(git_oid *oid, git_repository *repo, const char *path);
   GIT_EXTERN(int) git_blob_create_frombuffer(git_oid *oid, git_repository *repo, const void *buffer, size_t len);

   /// commit.h
   ///

   GIT_EXTERN(const git_oid *) git_commit_id(git_commit *commit);
   GIT_EXTERN(const char *) git_commit_message_encoding(git_commit *commit);
   GIT_EXTERN(const char *) git_commit_message(git_commit *commit);
   GIT_EXTERN(git_time_t) git_commit_time(git_commit *commit);
   GIT_EXTERN(int) git_commit_time_offset(git_commit *commit);
   GIT_EXTERN(const git_signature *) git_commit_committer(git_commit *commit);
   GIT_EXTERN(const git_signature *) git_commit_author(git_commit *commit);
   GIT_EXTERN(int) git_commit_tree(git_tree **tree_out, git_commit *commit);
   GIT_EXTERN(const git_oid *) git_commit_tree_oid(git_commit *commit);
   GIT_EXTERN(unsigned int) git_commit_parentcount(git_commit *commit);
   GIT_EXTERN(int) git_commit_parent(git_commit **parent, git_commit *commit, unsigned int n);
   GIT_EXTERN(const git_oid *) git_commit_parent_oid(git_commit *commit, unsigned int n);
   GIT_EXTERN(int) git_commit_create(git_oid *oid, git_repository *repo, const char *update_ref, const git_signature *author, const git_signature *committer, const char *message_encoding, const char *message, const git_tree *tree, int parent_count, const git_commit *parents[]);
   GIT_EXTERN(int) git_commit_create_v(git_oid *oid, git_repository *repo, const char *update_ref, const git_signature *author, const git_signature *committer, const char *message_encoding, const char *message, const git_tree *tree, int parent_count, ...);

   /// common.h
   ///

   GIT_EXTERN(void) git_strarray_free(git_strarray *array);
   GIT_EXTERN(void) git_libgit2_version(int *major, int *minor, int *rev);

   /// config.h
   ///

   GIT_EXTERN(int) git_config_find_global(char *global_config_path);
   GIT_EXTERN(int) git_config_find_system(char *system_config_path);
   GIT_EXTERN(int) git_config_open_global(git_config **out);
   GIT_EXTERN(int) git_config_file__ondisk(struct git_config_file **out, const char *path);
   GIT_EXTERN(int) git_config_new(git_config **out);
   GIT_EXTERN(int) git_config_add_file(git_config *cfg,struct git_config_file *file, int priority);
   GIT_EXTERN(int) git_config_add_file_ondisk(git_config *cfg, const char *path, int priority);
   GIT_EXTERN(int) git_config_open_ondisk(git_config **cfg, const char *path);
   GIT_EXTERN(void) git_config_free(git_config *cfg);
   GIT_EXTERN(int) git_config_get_int32(git_config *cfg, const char *name, int32_t *out);
   GIT_EXTERN(int) git_config_get_int64(git_config *cfg, const char *name, int64_t *out);
   GIT_EXTERN(int) git_config_get_bool(git_config *cfg, const char *name, int *out);
   GIT_EXTERN(int) git_config_get_string(git_config *cfg, const char *name, const char **out);
   GIT_EXTERN(int) git_config_set_int32(git_config *cfg, const char *name, int32_t value);
   GIT_EXTERN(int) git_config_set_int64(git_config *cfg, const char *name, int64_t value);
   GIT_EXTERN(int) git_config_set_bool(git_config *cfg, const char *name, int value);
   GIT_EXTERN(int) git_config_set_string(git_config *cfg, const char *name, const char *value);
   GIT_EXTERN(int) git_config_delete(git_config *cfg, const char *name);
   GIT_EXTERN(int) git_config_foreach(git_config *cfg, int (*callback)(const char *var_name, const char *value, void *payload), void *payload);

   /// errors.h
   ///

   GIT_EXTERN(const char *) git_lasterror(void);
   GIT_EXTERN(const char *) git_strerror(int num);
   GIT_EXTERN(void) git_clearerror(void);

   /// index.h
   ///

   GIT_EXTERN(int) git_index_open(git_index **index, const char *index_path);
   GIT_EXTERN(void) git_index_clear(git_index *index);
   GIT_EXTERN(void) git_index_free(git_index *index);
   GIT_EXTERN(int) git_index_read(git_index *index);
   GIT_EXTERN(int) git_index_write(git_index *index);
   GIT_EXTERN(int) git_index_find(git_index *index, const char *path);
   GIT_EXTERN(void) git_index_uniq(git_index *index);
   GIT_EXTERN(int) git_index_add(git_index *index, const char *path, int stage);
   GIT_EXTERN(int) git_index_add2(git_index *index, const git_index_entry *source_entry);
   GIT_EXTERN(int) git_index_append(git_index *index, const char *path, int stage);
   GIT_EXTERN(int) git_index_append2(git_index *index, const git_index_entry *source_entry);
   GIT_EXTERN(int) git_index_remove(git_index *index, int position);
   GIT_EXTERN(git_index_entry *) git_index_get(git_index *index, unsigned int n);
   GIT_EXTERN(unsigned int) git_index_entrycount(git_index *index);
   GIT_EXTERN(unsigned int) git_index_entrycount_unmerged(git_index *index);
   GIT_EXTERN(const git_index_entry_unmerged *) git_index_get_unmerged_bypath(git_index *index, const char *path);
   GIT_EXTERN(const git_index_entry_unmerged *) git_index_get_unmerged_byindex(git_index *index, unsigned int n);
   GIT_EXTERN(int) git_index_entry_stage(const git_index_entry *entry);
   GIT_EXTERN(int) git_index_read_tree(git_index *index, git_tree *tree);

   /// indexer.h
   ///

   GIT_EXTERN(int) git_indexer_new(git_indexer **out, const char *packname);
   GIT_EXTERN(int) git_indexer_run(git_indexer *idx, git_indexer_stats *stats);
   GIT_EXTERN(int) git_indexer_write(git_indexer *idx);
   GIT_EXTERN(const git_oid *) git_indexer_hash(git_indexer *idx);
   GIT_EXTERN(void) git_indexer_free(git_indexer *idx);

   /// object.h
   ///

   GIT_EXTERN(int) git_object_lookup(git_object **object, git_repository *repo, const git_oid *id, git_otype type);
   GIT_EXTERN(int) git_object_lookup_prefix(git_object **object_out, git_repository *repo, const git_oid *id, unsigned int len, git_otype type);
   GIT_EXTERN(const git_oid *) git_object_id(const git_object *obj);
   GIT_EXTERN(git_otype) git_object_type(const git_object *obj);
   GIT_EXTERN(git_repository *) git_object_owner(const git_object *obj);
   GIT_EXTERN(void) git_object_free(git_object *object);
   GIT_EXTERN(const char *) git_object_type2string(git_otype type);
   GIT_EXTERN(git_otype) git_object_string2type(const char *str);
   GIT_EXTERN(int) git_object_typeisloose(git_otype type);
   GIT_EXTERN(size_t) git_object__size(git_otype type);

   /// odb.h
   ///

   GIT_EXTERN(int) git_odb_new(git_odb **out);
   GIT_EXTERN(int) git_odb_open(git_odb **out, const char *objects_dir);
   GIT_EXTERN(int) git_odb_add_backend(git_odb *odb,struct git_odb_backend *backend, int priority);
   GIT_EXTERN(int) git_odb_add_alternate(git_odb *odb,struct git_odb_backend *backend, int priority);
   GIT_EXTERN(void) git_odb_free(git_odb *db);
   GIT_EXTERN(int) git_odb_read(git_odb_object **out, git_odb *db, const git_oid *id);
   GIT_EXTERN(int) git_odb_read_prefix(git_odb_object **out, git_odb *db, const git_oid *short_id, unsigned int len);
   GIT_EXTERN(int) git_odb_read_header(size_t *len_p, git_otype *type_p, git_odb *db, const git_oid *id);
   GIT_EXTERN(int) git_odb_exists(git_odb *db, const git_oid *id);
   GIT_EXTERN(int) git_odb_write(git_oid *oid, git_odb *odb, const void *data, size_t len, git_otype type);
   GIT_EXTERN(int) git_odb_open_wstream(git_odb_stream **stream, git_odb *db, size_t size, git_otype type);
   GIT_EXTERN(int) git_odb_open_rstream(git_odb_stream **stream, git_odb *db, const git_oid *oid);
   GIT_EXTERN(int) git_odb_hash(git_oid *id, const void *data, size_t len, git_otype type);
   GIT_EXTERN(int) git_odb_hashfile(git_oid *out, const char *path, git_otype type);
   GIT_EXTERN(void) git_odb_object_free(git_odb_object *object);
   GIT_EXTERN(const git_oid *) git_odb_object_id(git_odb_object *object);
   GIT_EXTERN(const void *) git_odb_object_data(git_odb_object *object);
   GIT_EXTERN(size_t) git_odb_object_size(git_odb_object *object);
   GIT_EXTERN(git_otype) git_odb_object_type(git_odb_object *object);

   /// odb_backend.h
   ///

   GIT_EXTERN(int) git_odb_backend_pack(struct git_odb_backend **backend_out, const char *objects_dir);
   GIT_EXTERN(int) git_odb_backend_loose(struct git_odb_backend **backend_out, const char *objects_dir, int compression_level, int do_fsync);

   /// oid.h
   ///

   GIT_EXTERN(int) git_oid_fromstr(git_oid *out, const char *str);
   GIT_EXTERN(int) git_oid_fromstrn(git_oid *out, const char *str, size_t length);
   GIT_EXTERN(void) git_oid_fromraw(git_oid *out, const unsigned char *raw);
   GIT_EXTERN(void) git_oid_fmt(char *str, const git_oid *oid);
   GIT_EXTERN(void) git_oid_pathfmt(char *str, const git_oid *oid);
   GIT_EXTERN(char *) git_oid_allocfmt(const git_oid *oid);
   GIT_EXTERN(char *) git_oid_to_string(char *out, size_t n, const git_oid *oid);
   GIT_EXTERN(void) git_oid_cpy(git_oid *out, const git_oid *src);
   GIT_EXTERN(int) git_oid_cmp(const git_oid *a, const git_oid *b);
   GIT_EXTERN(int) git_oid_ncmp(const git_oid *a, const git_oid *b, unsigned int len);
   GIT_EXTERN(int) git_oid_streq(const git_oid *a, const char *str);

   /// reflog.h
   ///

   GIT_EXTERN(int) git_reflog_read(git_reflog **reflog, git_reference *ref);
   GIT_EXTERN(int) git_reflog_write(git_reference *ref, const git_oid *oid_old, const git_signature *committer, const char *msg);
   GIT_EXTERN(int) git_reflog_rename(git_reference *ref, const char *new_name);
   GIT_EXTERN(int) git_reflog_delete(git_reference *ref);
   GIT_EXTERN(unsigned int) git_reflog_entrycount(git_reflog *reflog);
   GIT_EXTERN(const git_reflog_entry *) git_reflog_entry_byindex(git_reflog *reflog, unsigned int idx);
   GIT_EXTERN(const git_oid *) git_reflog_entry_oidold(const git_reflog_entry *entry);
   GIT_EXTERN(const git_oid *) git_reflog_entry_oidnew(const git_reflog_entry *entry);
   GIT_EXTERN(git_signature *) git_reflog_entry_committer(const git_reflog_entry *entry);
   GIT_EXTERN(char *) git_reflog_entry_msg(const git_reflog_entry *entry);
   GIT_EXTERN(void) git_reflog_free(git_reflog *reflog);

   /// refs.h
   ///

   GIT_EXTERN(int) git_reference_lookup(git_reference **reference_out, git_repository *repo, const char *name);
   GIT_EXTERN(int) git_reference_create_symbolic(git_reference **ref_out, git_repository *repo, const char *name, const char *target, int force);
   GIT_EXTERN(int) git_reference_create_oid(git_reference **ref_out, git_repository *repo, const char *name, const git_oid *id, int force);
   GIT_EXTERN(const git_oid *) git_reference_oid(git_reference *ref);
   GIT_EXTERN(const char *) git_reference_target(git_reference *ref);
   GIT_EXTERN(git_rtype) git_reference_type(git_reference *ref);
   GIT_EXTERN(const char *) git_reference_name(git_reference *ref);
   GIT_EXTERN(int) git_reference_resolve(git_reference **resolved_ref, git_reference *ref);
   GIT_EXTERN(git_repository *) git_reference_owner(git_reference *ref);
   GIT_EXTERN(int) git_reference_set_target(git_reference *ref, const char *target);
   GIT_EXTERN(int) git_reference_set_oid(git_reference *ref, const git_oid *id);
   GIT_EXTERN(int) git_reference_rename(git_reference *ref, const char *new_name, int force);
   GIT_EXTERN(int) git_reference_delete(git_reference *ref);
   GIT_EXTERN(int) git_reference_packall(git_repository *repo);
   GIT_EXTERN(int) git_reference_listall(git_strarray *array, git_repository *repo, unsigned int list_flags);
   GIT_EXTERN(int) git_reference_foreach(git_repository *repo, unsigned int list_flags, int (*callback)(const char *, void *), void *payload);
   GIT_EXTERN(int) git_reference_is_packed(git_reference *ref);
   GIT_EXTERN(int) git_reference_reload(git_reference *ref);
   GIT_EXTERN(void) git_reference_free(git_reference *ref);
   GIT_EXTERN(const char *) git_reference_shorthand(const git_reference *ref);

   /// remote.h
   ///

   GIT_EXTERN(int) git_remote_new(git_remote **out, git_repository *repo, const char *url, const char *name);
   GIT_EXTERN(int) git_remote_load(git_remote **out, git_repository *repo, const char *name);
   GIT_EXTERN(const char *) git_remote_name(git_remote *remote);
   GIT_EXTERN(const char *) git_remote_url(git_remote *remote);
   GIT_EXTERN(const git_refspec *) git_remote_fetchspec(git_remote *remote);
   GIT_EXTERN(const git_refspec *) git_remote_pushspec(git_remote *remote);
   GIT_EXTERN(int) git_remote_connect(git_remote *remote, int direction);
   GIT_EXTERN(int) git_remote_ls(git_remote *remote, git_headlist_cb list_cb, void *payload);
   GIT_EXTERN(int) git_remote_download(char **filename, git_remote *remote);
   GIT_EXTERN(int) git_remote_connected(git_remote *remote);
   GIT_EXTERN(void) git_remote_disconnect(git_remote *remote);
   GIT_EXTERN(void) git_remote_free(git_remote *remote);
   GIT_EXTERN(int) git_remote_update_tips(git_remote *remote);
   GIT_EXTERN(int) git_remote_valid_url(const char *url);

   /// repository.h
   ///

   GIT_EXTERN(int) git_repository_open(git_repository **repository, const char *path);
   GIT_EXTERN(int) git_repository_discover(char *repository_path, size_t size, const char *start_path, int across_fs, const char *ceiling_dirs);
   GIT_EXTERN(void) git_repository_free(git_repository *repo);
   GIT_EXTERN(int) git_repository_init(git_repository **repo_out, const char *path, unsigned is_bare);
   GIT_EXTERN(int) git_repository_head(git_reference **head_out, git_repository *repo);
   GIT_EXTERN(int) git_repository_head_detached(git_repository *repo);
   GIT_EXTERN(int) git_repository_head_orphan(git_repository *repo);
   GIT_EXTERN(int) git_repository_is_empty(git_repository *repo);
   GIT_EXTERN(const char *) git_repository_path(git_repository *repo);
   GIT_EXTERN(const char *) git_repository_workdir(git_repository *repo);
   GIT_EXTERN(int) git_repository_set_workdir(git_repository *repo, const char *workdir);
   GIT_EXTERN(int) git_repository_is_bare(git_repository *repo);
   GIT_EXTERN(int) git_repository_config(git_config **out, git_repository *repo);
   GIT_EXTERN(void) git_repository_set_config(git_repository *repo, git_config *config);
   GIT_EXTERN(int) git_repository_odb(git_odb **out, git_repository *repo);
   GIT_EXTERN(void) git_repository_set_odb(git_repository *repo, git_odb *odb);
   GIT_EXTERN(int) git_repository_index(git_index **index, git_repository *repo);
   GIT_EXTERN(void) git_repository_set_index(git_repository *repo, git_index *index);

   /// revwalk.h
   ///

   GIT_EXTERN(int) git_revwalk_new(git_revwalk **walker, git_repository *repo);
   GIT_EXTERN(void) git_revwalk_reset(git_revwalk *walker);
   GIT_EXTERN(int) git_revwalk_push(git_revwalk *walk, const git_oid *oid);
   GIT_EXTERN(int) git_revwalk_hide(git_revwalk *walk, const git_oid *oid);
   GIT_EXTERN(int) git_revwalk_next(git_oid *oid, git_revwalk *walk);
   GIT_EXTERN(void) git_revwalk_sorting(git_revwalk *walk, unsigned int sort_mode);
   GIT_EXTERN(void) git_revwalk_free(git_revwalk *walk);
   GIT_EXTERN(git_repository *) git_revwalk_repository(git_revwalk *walk);

   /// signature.h
   ///

   GIT_EXTERN(int) git_signature_new(git_signature **sig_out, const char *name, const char *email, git_time_t time, int offset);
   GIT_EXTERN(int) git_signature_now(git_signature **sig_out, const char *name, const char *email);
   GIT_EXTERN(git_signature *) git_signature_dup(const git_signature *sig);
   GIT_EXTERN(void) git_signature_free(git_signature *sig);

   /// status.h
   ///

   GIT_EXTERN(int) git_status_foreach(git_repository *repo, int (*callback)(const char *, unsigned int, void *), void *payload);
   GIT_EXTERN(int) git_status_file(unsigned int *status_flags, git_repository *repo, const char *path);
   GIT_EXTERN(int) git_status_should_ignore(git_repository *repo, const char *path, int *ignored);

   /// tag.h
   ///

   GIT_EXTERN(const git_oid *) git_tag_id(git_tag *tag);
   GIT_EXTERN(int) git_tag_target(git_object **target, git_tag *tag);
   GIT_EXTERN(const git_oid *) git_tag_target_oid(git_tag *tag);
   GIT_EXTERN(git_otype) git_tag_type(git_tag *tag);
   GIT_EXTERN(const char *) git_tag_name(git_tag *tag);
   GIT_EXTERN(const git_signature *) git_tag_tagger(git_tag *tag);
   GIT_EXTERN(const char *) git_tag_message(git_tag *tag);
   GIT_EXTERN(int) git_tag_create(git_oid *oid, git_repository *repo, const char *tag_name, const git_object *target, const git_signature *tagger, const char *message, int force);
   GIT_EXTERN(int) git_tag_create_frombuffer(git_oid *oid, git_repository *repo, const char *buffer, int force);
   GIT_EXTERN(int) git_tag_create_lightweight(git_oid *oid, git_repository *repo, const char *tag_name, const git_object *target, int force);
   GIT_EXTERN(int) git_tag_delete(git_repository *repo, const char *tag_name);
   GIT_EXTERN(int) git_tag_list(git_strarray *tag_names, git_repository *repo);
   GIT_EXTERN(int) git_tag_list_match(git_strarray *tag_names, const char *pattern, git_repository *repo);

   /// threads.h
   ///

   GIT_EXTERN(void) git_threads_init(void);
   GIT_EXTERN(void) git_threads_shutdown(void);

   /// tree.h
   ///

   GIT_EXTERN(const git_oid *) git_tree_id(git_tree *tree);
   GIT_EXTERN(unsigned int) git_tree_entrycount(git_tree *tree);
   GIT_EXTERN(const git_tree_entry *) git_tree_entry_byname(git_tree *tree, const char *filename);
   GIT_EXTERN(const git_tree_entry *) git_tree_entry_byindex(git_tree *tree, unsigned int idx);
   GIT_EXTERN(unsigned int) git_tree_entry_attributes(const git_tree_entry *entry);
   GIT_EXTERN(const char *) git_tree_entry_name(const git_tree_entry *entry);
   GIT_EXTERN(const git_oid *) git_tree_entry_id(const git_tree_entry *entry);
   GIT_EXTERN(git_otype) git_tree_entry_type(const git_tree_entry *entry);
   GIT_EXTERN(int) git_tree_entry_2object(git_object **object_out, git_repository *repo, const git_tree_entry *entry);
   GIT_EXTERN(int) git_tree_create_fromindex(git_oid *oid, git_index *index);

   GIT_EXTERN(int) git_treebuilder_create(git_treebuilder **builder_p, const git_tree *source);
   GIT_EXTERN(void) git_treebuilder_clear(git_treebuilder *bld);
   GIT_EXTERN(void) git_treebuilder_free(git_treebuilder *bld);
   GIT_EXTERN(const git_tree_entry *) git_treebuilder_get(git_treebuilder *bld, const char *filename);
   GIT_EXTERN(int) git_treebuilder_insert(git_tree_entry **entry_out, git_treebuilder *bld, const char *filename, const git_oid *id, unsigned int attributes);
   GIT_EXTERN(int) git_treebuilder_remove(git_treebuilder *bld, const char *filename);
   GIT_EXTERN(void) git_treebuilder_filter(git_treebuilder *bld, int (*filter)(const git_tree_entry *, void *), void *payload);
   GIT_EXTERN(int) git_treebuilder_write(git_oid *oid, git_repository *repo, git_treebuilder *bld);
   GIT_EXTERN(int) git_tree_get_subtree(git_tree **subtree, git_tree *root, const char *subtree_path);
   GIT_EXTERN(int) git_tree_walk(git_tree *tree, git_treewalk_cb callback, int mode, void *payload);

   /// windows.h
   ///

   GIT_EXTERN(void) gitwin_set_codepage(unsigned int codepage);
   GIT_EXTERN(unsigned int) gitwin_get_codepage(void);
   GIT_EXTERN(void) gitwin_set_utf8(void);

   /*
// GIT_EXTERNs later inlined
function git_blob_lookup(var blob: Pgit_blob; repo: Pgit_repository; const id: Pgit_oid): Integer; stdcall;
function git_commit_lookup(var commit: Pgit_commit; repo: Pgit_repository; const id: Pgit_oid): Integer; stdcall;
function git_tag_lookup(var tag: Pgit_tag; repo: Pgit_repository; const id: Pgit_oid): Integer; stdcall;
function git_tree_lookup(var tree: Pgit_tree; repo: Pgit_repository; const id: Pgit_oid): Integer; stdcall;
procedure git_commit_free(commit: Pgit_commit);
procedure git_tag_free(tag: Pgit_tag);
procedure git_tree_free(tree: Pgit_tree);

// Helpers
function time_t__to__TDateTime(t: time_t; const aAdjustMinutes: Integer = 0): TDateTime;
function git_commit_DateTime(commit: Pgit_commit): TDateTime;

implementation

var
  libgit2: THandle;

function git_blob_lookup(var blob: Pgit_blob; repo: Pgit_repository; const id: Pgit_oid): Integer; stdcall;
begin
   // return git_object_lookup((git_object **)blob, repo, id, GIT_OBJ_BLOB);
   Result := git_object_lookup(Pgit_object(blob), repo, id, GIT_OBJ_BLOB);
end;

function git_commit_lookup(var commit: Pgit_commit; repo: Pgit_repository; const id: Pgit_oid): Integer; stdcall;
begin
   // return git_object_lookup((git_object **)commit, repo, id, GIT_OBJ_COMMIT);
   Result := git_object_lookup(commit, repo, id, GIT_OBJ_COMMIT);
end;

function git_tag_lookup(var tag: Pgit_tag; repo: Pgit_repository; const id: Pgit_oid): Integer; stdcall;
begin
   // return git_object_lookup((git_object **)tag, repo, id, GIT_OBJ_TAG);
   Result := git_object_lookup(Pgit_object(tag), repo, id, GIT_OBJ_TAG);
end;

function git_tree_lookup(var tree: Pgit_tree; repo: Pgit_repository; const id: Pgit_oid): Integer; stdcall;
begin
   // return git_object_lookup((git_object **)tree, repo, id, GIT_OBJ_TREE);
   Result := git_object_lookup(Pgit_object(tree), repo, id, GIT_OBJ_TREE);
end;

procedure git_commit_free(commit: Pgit_commit);
begin
   git_object_free(commit);
end;

procedure git_tag_free(tag: Pgit_tag);
begin
   git_object_free(tag);
end;

procedure git_tree_free(tree: Pgit_tree);
begin
   git_object_free(tree);
end;

function time_t__to__TDateTime(t: time_t; const aAdjustMinutes: Integer = 0): TDateTime;
const
   UnixStartDate: TDateTime = 25569.0; // 01/01/1970
begin
   Result := (t / SecsPerDay) + UnixStartDate;                          //   Result := DateUtils.IncSecond(EncodeDate(1970,1,1), t);
   if aAdjustMinutes <> 0 then
      Result := ((Result * MinsPerDay) + aAdjustMinutes) / MinsPerDay;  //      Result := DateUtils.IncMinute(Result, aAdjustMinutes);
end;

function git_commit_DateTime(commit: Pgit_commit): TDateTime;
var
   t: time_t;
   time_offset: Integer;
begin
   t := git_commit_time(commit);
   time_offset := git_commit_time_offset(commit);

   Result := time_t__to__TDateTime(t, time_offset);
end; */

GIT_EXTERN(int) git_commit_entry_last_commit_id(git_oid *out,	const git_repository *repo,
	const git_commit *commit,	const char *path);
GIT_EXTERN(int) git_reference_name_to_id(
	git_oid *out, git_repository *repo, const char *name);
GIT_EXTERN(int) git_commit_lookup(
	git_commit **commit, git_repository *repo, const git_oid *id);
GIT_EXTERN(void) git_commit_free(git_commit *commit);
GIT_EXTERN(const char *) git_commit_summary(git_commit *commit);

#endif
